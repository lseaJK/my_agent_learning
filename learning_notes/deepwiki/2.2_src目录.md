## src 目录
`src` 是 DeepWiki-Open 前端应用的核心目录，基于 **Next.js** 框架开发，包含了所有前端代码（页面、组件、工具函数、类型定义等），是用户交互界面和前端逻辑的实现载体。


| 目录/文件               | 作用说明                                                                 | 初学者优先级 |
|-------------------------|--------------------------------------------------------------------------|--------------|
| `app/`                  | Next.js 13+ 引入的 App Router 目录，存放页面路由和页面组件               | ★★★★★        |
| `components/`           | React 组件库，存放可复用的 UI 组件（如按钮、图表、模态框等）             | ★★★★☆        |
| `types/`                | TypeScript 类型定义文件，规范数据结构（如接口、对象格式）                 | ★★★☆☆        |
| `hooks/`                | 自定义 React Hooks，封装可复用的逻辑（如数据请求、状态管理）             | ★★☆☆☆        |
| `contexts/`             | React Context，管理全局状态（如多语言切换、用户配置）                     | ★★☆☆☆        |
| `utils/`                | 工具函数集合（如 URL 处理、数据解码、WebSocket 连接）                     | ★★☆☆☆        |
| `i18n.ts`               | 国际化配置入口，关联多语言翻译文件                                       | ★☆☆☆☆        |
| `wiki/messages/`        | 多语言翻译文件（如 en.json、zh.json），存放各语言的文本内容               | ★☆☆☆☆        |

---

## 一、`app/` 目录
`app/` 是 Next.js 的路由核心，页面的 URL 路径与目录结构一一对应，是最直观的入口。  
- 重点看 `app/[owner]/[repo]/page.tsx`：这是项目的核心页面（仓库 Wiki 生成页面），包含了页面渲染、数据处理、用户交互（如生成 Wiki、切换页面）等核心逻辑。  
  初学者可以先关注：  
  - 页面如何从 URL 中获取参数（`useParams`、`searchParams`）；  
  - 状态管理（`useState` 定义的加载状态、错误信息等）；  
  - 核心函数（如 `generatePageContent` 如何调用 API 生成 Wiki 内容）。  


### 一、先掌握 App Router 的核心规则（初学者必懂）
在拆解具体文件前，先明确 Next.js 对 `app/` 目录的核心约定（这是理解所有结构的基础）：

| 规则                | 说明                                                                 |
|---------------------|----------------------------------------------------------------------|
| 文件系统路由        | `app/` 下的目录结构直接映射 URL，例如 `app/foo/bar/page.tsx` → `https://域名/foo/bar` |
| 动态路由            | 方括号 `[]` 包裹的目录是「动态参数路由」，匹配任意值（如 `[owner]` 匹配任意用户名） |
| 特殊文件约定        | Next.js 定义了一批特殊文件（如 `page.tsx`/`layout.tsx`），实现页面、布局、加载态等功能 |
| 服务端/客户端组件   | `app/` 下组件默认是「服务端组件（Server Component）」，加 `'use client'` 才是客户端组件 |


结合项目业务场景，`app/` 目录的典型结构如下（按优先级排序）：
```
app/
├── [owner]/                # 一级动态路由：仓库所有者（如 GitHub 用户名）
│   ├── [repo]/             # 二级动态路由：仓库名称（如 wiki-demo）
│   │   ├── page.tsx        # 核心业务页：Wiki 生成/展示页（路由：/[owner]/[repo]）
│   │   ├── layout.tsx      # 该路由专属布局（可选，如侧边栏）
│   │   ├── loading.tsx     # 加载态组件（可选，生成 Wiki 时的骨架屏）
│   │   └── error.tsx       # 错误边界（可选，该页面出错时的提示）
├── layout.tsx              # 根布局：全局通用布局（导航、页脚、全局样式）
├── page.tsx                # 应用首页（路由：/，引导用户输入仓库信息）
├── globals.css             # 全局样式文件（字体、主题色、重置样式）
├── not-found.tsx           # 404 页面（匹配不到路由时显示）
└── api/                    # 前端内置 API 路由（可选，代理后端请求）
    └── generate/
        └── route.ts        # Wiki 生成的 API 接口（处理 POST 请求）
```

#### （1）`layout.tsx`（根布局）
- **核心作用**：整个应用的「最外层容器」，所有页面都会被该布局包裹，负责全局通用逻辑/UI。
- **初学者重点看**：
  ```tsx
  // 示例核心代码片段
  'use client'; // 若用到 useState/Context，需声明客户端组件
  import './globals.css'; // 引入全局样式
  import { LanguageContextProvider } from '@/contexts/LanguageContext'; // 全局多语言上下文

  export default function RootLayout({ children }: { children: React.ReactNode }) {
    return (
      <html lang="zh">
        <body>
          {/* 全局上下文：让所有页面都能访问语言状态 */}
          <LanguageContextProvider>
            <header> {/* 全局导航栏：Logo、语言切换按钮 */} </header>
            <main>{children}</main> {/* children 是各页面的内容（如首页/核心页） */}
            <footer> {/* 全局页脚：版权、链接 */} </footer>
          </LanguageContextProvider>
        </body>
      </html>
    );
  }

  // 页面元信息（标题、图标等）
  export const metadata = {
    title: 'DeepWiki-Open',
    description: '自动生成仓库 Wiki',
  };
  ```
- **关键知识点**：
  - `children` 是动态插槽，会渲染当前路由对应的 `page.tsx` 内容；
  - `metadata` 用于设置页面标题、meta 标签（SEO/浏览器标签）；
  - 全局状态（如多语言、用户配置）通常在这里注入 Context，让所有页面共享。

#### （2）`page.tsx`（首页）
- **路由映射**：`/`（根路径），应用的入口页。
- **核心作用**：引导用户输入「仓库所有者」和「仓库名称」，点击按钮跳转到 `/[owner]/[repo]` 核心页。
- **初学者重点拆解**：
  ```tsx
  'use client';
  import { useState } from 'react';
  import { useRouter } from 'next/navigation'; // Next.js 路由跳转

  export default function Home() {
    // 1. 状态管理：存储用户输入的 owner/repo
    const [owner, setOwner] = useState('');
    const [repo, setRepo] = useState('');
    const router = useRouter();

    // 2. 表单提交逻辑：跳转到动态路由页面
    const handleSubmit = (e: React.FormEvent) => {
      e.preventDefault();
      if (!owner || !repo) return; // 空值校验
      router.push(`/${owner}/${repo}`); // 跳转到核心业务页
    };

    // 3. UI 渲染：输入框 + 提交按钮
    return (
      <div className="container">
        <form onSubmit={handleSubmit}>
          <input
            placeholder="仓库所有者（如 GitHub 用户名）"
            value={owner}
            onChange={(e) => setOwner(e.target.value)}
          />
          <input
            placeholder="仓库名称（如 wiki-demo）"
            value={repo}
            onChange={(e) => setRepo(e.target.value)}
          />
          <button type="submit" disabled={!owner || !repo}>
            生成 Wiki
          </button>
        </form>
      </div>
    );
  }
  ```
- **关键知识点**：
  - `useRouter()` 是 Next.js 客户端路由跳转工具；
  - 表单提交时的空值校验、按钮禁用状态（`disabled`）是前端基础交互逻辑；
  - 该页面是纯客户端组件（`'use client'`），因为需要处理输入/跳转等交互。

#### （3）`not-found.tsx`（404 页面）
- **核心作用**：当用户访问不存在的路由（如 `/foo/bar123`，但该仓库不存在）时显示。
- **极简示例**：
  ```tsx
  export default function NotFound() {
    return (
      <div className="container">
        <h1>404 - 页面不存在</h1>
        <p>请检查仓库所有者/名称是否正确</p>
        <a href="/">返回首页</a>
      </div>
    );
  }
  ```

### 2. 动态路由目录：`[owner]/[repo]/`
这是项目的**核心业务目录**，对应 URL `/[owner]/[repo]`（如 `/deep-wiki/wiki-demo`），所有 Wiki 生成/展示逻辑都在这里。

#### （1）`page.tsx`（核心业务页）
这是整个应用的核心文件，初学者需按「逻辑模块」拆解：
```tsx
'use client'; // 必须声明：用到 useState/useParams 等客户端 API
import { useState } from 'react';
import { useParams, useSearchParams } from 'next/navigation'; // 获取路由参数
import Markdown from '@/components/Markdown'; // 引入 UI 组件
import { WikiStructure } from '@/types/wiki/wikistructure'; // 引入类型定义
import { generateWiki } from '@/utils/api'; // 引入 API 调用工具

export default function WikiPage() {
  // ========== 1. 参数获取 ==========
  const params = useParams(); // 获取动态路由参数：owner/repo
  const searchParams = useSearchParams(); // 获取 URL 查询参数（如 ?model=gpt-3.5）
  const owner = params.owner as string;
  const repo = params.repo as string;
  const model = searchParams.get('model') || 'gpt-3.5';

  // ========== 2. 状态管理 ==========
  const [loading, setLoading] = useState(false); // 加载状态
  const [error, setError] = useState<string | null>(null); // 错误状态
  const [wikiContent, setWikiContent] = useState<WikiStructure | null>(null); // Wiki 数据

  // ========== 3. 核心业务逻辑 ==========
  // 生成 Wiki 的核心函数
  const handleGenerateWiki = async () => {
    setLoading(true);
    setError(null);
    try {
      // 调用后端 API，获取 Wiki 数据
      const data = await generateWiki({ owner, repo, model });
      setWikiContent(data); // 存储 Wiki 数据
    } catch (err) {
      setError('生成 Wiki 失败，请重试'); // 错误处理
    } finally {
      setLoading(false); // 结束加载
    }
  };

  // ========== 4. 条件渲染 ==========
  return (
    <div className="container">
      <div className="wiki-header">
        <h1>{owner}/{repo} - Wiki</h1>
        <button className="btn" onClick={handleGenerateWiki} disabled={loading}>
          {loading ? '生成中...' : '重新生成 Wiki'}
        </button>
      </div>

      {/* 加载态 */}
      {loading && <div className="loading">加载中...</div>}

      {/* 错误提示 */}
      {error && <div className="error">{error}</div>}

      {/* Wiki 内容渲染 */}
      {wikiContent && <Markdown content={wikiContent.content} />}
    </div>
  );
}
```
- **核心模块拆解**：
  ① **参数获取**：`useParams()` 拿动态路由的 `owner/repo`，`useSearchParams()` 拿 URL 后的查询参数（如模型类型）；
  ② **状态管理**：用 `useState` 管理「加载/错误/Wiki 数据」三个核心状态，覆盖用户操作的全流程；
  ③ **业务逻辑**：`handleGenerateWiki` 封装 API 调用，包含「开始加载→调用接口→存储数据/处理错误→结束加载」的完整流程；
  ④ **条件渲染**：根据状态显示不同内容（加载中/错误/正常 Wiki 内容），是前端交互的核心模式。

#### （2）`loading.tsx`（加载态组件，可选）
- **核心作用**：页面数据加载时显示骨架屏，提升用户体验（替代简单的「加载中...」文字）。
- **示例**：
  ```tsx
  export default function Loading() {
    return (
      <div className="wiki-skeleton">
        <div className="skeleton-header"></div>
        <div className="skeleton-content"></div>
      </div>
    );
  }
  ```

#### （3）`error.tsx`（错误边界，可选）
- **核心作用**：仅捕获 `/[owner]/[repo]` 路由下的错误（如 API 异常、组件渲染失败），避免整个应用崩溃。
- **示例**：
  ```tsx
  'use client';
  export default function Error({ error, reset }: { error: Error; reset: () => void }) {
    return (
      <div className="error-container">
        <h2>出错了：{error.message}</h2>
        <button className="btn" onClick={() => reset()}>重试</button>
      </div>
    );
  }
  ```

### 3. `api/` 目录（前端内置 API 路由，可选）
- **核心作用**：Next.js 允许在 `app/api/` 下定义 API 接口，作为前端和后端的「代理层」（处理跨域、参数校验、请求转发）。
- **示例：`app/api/generate/route.ts`**：
  ```tsx
  // 服务端组件（默认），无需 'use client'
  import { NextRequest, NextResponse } from 'next/server';

  // 处理 POST 请求（前端调用生成 Wiki 的接口）
  export async function POST(req: NextRequest) {
    try {
      // 1. 获取前端传参
      const { owner, repo, model } = await req.json();

      // 2. 参数校验
      if (!owner || !repo) {
        return NextResponse.json({ error: '缺少参数' }, { status: 400 });
      }

      // 3. 调用后端 API
      const res = await fetch(`${process.env.BACKEND_URL}/generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ owner, repo, model }),
      });

      const data = await res.json();
      return NextResponse.json(data); // 返回到前端
    } catch (err) {
      return NextResponse.json({ error: '服务器错误' }, { status: 500 });
    }
  }
  ```
- **关键知识点**：
  - `route.ts` 是 API 路由的核心文件，支持 `GET/POST/PUT` 等方法；
  - 该文件运行在服务器端，可安全使用环境变量（如 `process.env.BACKEND_URL`），避免暴露后端地址；
  - 作用：解决跨域问题（前端直接调后端可能跨域，通过 Next.js 代理转发）、统一参数校验。

---

## 二、`components/`目录：理解 UI 组件
`components/` 存放了页面中用到的所有可复用组件，是构成界面的「积木」。  
- 从基础组件入手：比如 `Markdown.tsx`（渲染 Markdown 文本）、`Mermaid.tsx`（渲染流程图），这些组件直接影响用户看到的内容，逻辑相对简单。  
- 再看交互组件：比如 `Ask.tsx`（问答模态框）、`ModelSelectionModal.tsx`（模型选择弹窗），理解组件如何响应用户操作（如点击、输入）。  

### 深度拆解 `components/` 目录（React UI 组件核心）
`components/` 是 DeepWiki-Open 前端的「UI 积木库」，所有可视化界面元素（按钮、弹窗、Markdown 渲染、问答面板等）都封装在这里，遵循 **「单一职责、可复用、低耦合」** 原则，被 `app/` 目录下的页面组件调用，构成完整的用户界面。

```
components/
├── ui/                  # 基础通用UI组件（无业务耦合，可跨项目复用）
│   ├── Button.tsx       # 通用按钮（主/次按钮、禁用态、点击回调）
│   ├── Input.tsx        # 通用输入框（受控、占位符、禁用态）
│   └── Modal.tsx        # 通用弹窗容器（显隐控制、关闭回调）
├── wiki/                # Wiki业务专属组件（绑定Wiki核心逻辑）
│   ├── Markdown.tsx     # Markdown文本渲染（支持GFM、代码高亮）
│   ├── Mermaid.tsx      # Mermaid流程图渲染（架构图/步骤图）
│   ├── Ask.tsx          # Wiki问答弹窗（上下文提问、异步回答）
│   └── WikiSidebar.tsx  # Wiki侧边栏（页面导航、目录跳转）
└── common/              # 全局业务组件（跨Wiki场景复用）
    ├── ModelSelectionModal.tsx  # 模型选择弹窗（GPT-3.5/GPT-4切换）
    └── LoadingSkeleton.tsx      # 加载骨架屏（替代文字加载态）
```

#### （1）`Button.tsx`（通用按钮）
- **核心作用**：封装按钮样式、交互逻辑，避免重复写 `onClick`/`disabled`/样式；
- **核心代码（简化版）**：
  ```tsx
  'use client'; // 需处理点击事件，声明客户端组件

  // Step 1: TypeScript接口定义Props（输入），明确参数类型
  interface ButtonProps {
    children: React.ReactNode;       // 按钮文字/图标
    onClick?: () => void;            // 点击回调（可选）
    disabled?: boolean;              // 禁用态（默认false）
    variant?: 'primary' | 'secondary'; // 按钮类型（主/次）
    className?: string;              // 自定义样式（扩展用）
  }

  // Step 2: 组件逻辑（动态拼接样式、绑定事件）
  export default function Button({
    children,
    onClick,
    disabled = false,
    variant = 'primary',
    className = '',
  }: ButtonProps) {
    // 动态样式：基础样式 + 变体样式 + 自定义样式
    const btnClass = `btn ${
      variant === 'primary' ? 'btn-primary' : 'btn-secondary'
    } ${className}`;

    return (
      <button
        className={btnClass}
        onClick={onClick}
        disabled={disabled}
        type="button"
      >
        {children}
      </button>
    );
  }
  ```
- **关键知识点**：
  ✅ `Props` 接口：TypeScript 类型约束，提前拦截传参错误（比如传 `variant="xxx"` 会报错）；
  ✅ 变体（`variant`）：通过参数控制样式，实现「一套组件适配多场景」；
  ✅ 扩展类名（`className`）：保留自定义样式入口，兼顾复用性和灵活性；
- **调用场景**：首页的「生成 Wiki」按钮、弹窗的「确认/取消」按钮、核心页的「重新生成」按钮。

#### （2）`Modal.tsx`（通用弹窗容器）
- **核心作用**：封装弹窗的显隐、遮罩、关闭逻辑，所有弹窗（模型选择、问答）都基于此扩展；
- **核心代码（简化版）**：
  ```tsx
  'use client';
  import { useEffect } from 'react';

  interface ModalProps {
    open: boolean;          // 控制弹窗显隐（必传）
    onClose: () => void;    // 关闭回调（必传）
    children: React.ReactNode; // 弹窗内容（插槽）
  }

  export default function Modal({ open, onClose, children }: ModalProps) {
    // 副作用：弹窗打开时禁止页面滚动，关闭时恢复
    useEffect(() => {
      const body = document.body;
      if (open) body.style.overflow = 'hidden';
      return () => { body.style.overflow = 'auto'; };
    }, [open]);

    // 未打开时不渲染任何内容
    if (!open) return null;

    return (
      <div className="modal-overlay" onClick={onClose}>
        {/* 点击内容区不触发关闭 */}
        <div className="modal-content" onClick={(e) => e.stopPropagation()}>
          {/* 关闭按钮 */}
          <button className="modal-close" onClick={onClose}>×</button>
          {/* 弹窗内容（子组件插槽） */}
          {children}
        </div>
      </div>
    );
  }
  ```
- **关键知识点**：
  ✅ 受控弹窗：通过 `open` props 控制显隐，符合 React 单向数据流；
  ✅ 事件冒泡：`e.stopPropagation()` 避免点击弹窗内容区触发遮罩关闭；
  ✅ 副作用（`useEffect`）：处理 DOM 操作（页面滚动），组件卸载时恢复原状；
- **调用场景**：`ModelSelectionModal.tsx`、`Ask.tsx` 等所有弹窗组件的底层容器。

### 2. Wiki 业务专属组件（`wiki/` 目录）
这类组件绑定 Wiki 核心业务，是「定制化积木」，仅在 Wiki 页面使用，包含业务逻辑+UI 渲染。

#### （1）`Markdown.tsx`（Wiki 核心渲染组件）
- **核心作用**：渲染 Wiki 的 Markdown 文本，支持表格、代码高亮、链接跳转等特性；
- **核心代码（简化版）**：
  ```tsx
  'use client';
  // 第三方库：Markdown渲染+语法扩展+代码高亮
  import ReactMarkdown from 'react-markdown';
  import remarkGfm from 'remark-gfm'; // 支持GFM（表格、任务列表）
  import rehypeHighlight from 'rehype-highlight'; // 代码高亮
  import 'highlight.js/styles/github.css'; // 代码高亮样式

  interface MarkdownProps {
    content: string;       // 要渲染的Markdown文本（必传）
    className?: string;    // 自定义样式（可选）
  }

  export default function Markdown({ content, className }: MarkdownProps) {
    // 空内容兜底
    if (!content) return <div className={className}>暂无Wiki内容</div>;

    return (
      <div className={`markdown-container ${className}`}>
        <ReactMarkdown
          // 启用GFM语法（GitHub Flavored Markdown）
          remarkPlugins={[remarkGfm]}
          // 启用代码高亮
          rehypePlugins={[rehypeHighlight]}
          // 自定义组件：覆盖默认<a>标签，新标签页打开
          components={{
            a: ({ href, children }) => (
              <a 
                href={href} 
                target="_blank" 
                rel="noopener noreferrer"
              >
                {children}
              </a>
            ),
            // 识别Mermaid代码块，调用<Mermaid />组件渲染
            code: ({ className, children }) => {
              if (className?.includes('language-mermaid')) {
                return <Mermaid code={children as string} />;
              }
              // 普通代码块默认渲染
              return <code className={className}>{children}</code>;
            },
          }}
        >
          {content}
        </ReactMarkdown>
      </div>
    );
  }

  // 引入Mermaid组件（下文拆解）
  import Mermaid from './Mermaid';
  ```
- **关键知识点**：
  ✅ 第三方库复用：React 生态成熟的 Markdown 渲染方案（`react-markdown` + 插件），避免重复造轮子；
  ✅ 自定义组件：覆盖默认标签（如 `<a>`）或扩展新功能（如 Mermaid 代码块）；
  ✅ 兜底逻辑：空内容时显示提示，提升用户体验；
- **调用场景**：核心页（`app/[owner]/[repo]/page.tsx`）中渲染 `wikiContent.content`。

#### （2）`Mermaid.tsx`（流程图渲染组件）
- **核心作用**：解析并渲染 Wiki 中的 Mermaid 代码（如架构图、业务流程）；
- **核心代码（简化版）**：
  ```tsx
  'use client';
  import { useEffect, useRef } from 'react';
  import mermaid from 'mermaid'; // Mermaid官方库

  interface MermaidProps {
    code: string; // Mermaid代码（必传）
  }

  export default function Mermaid({ code }: MermaidProps) {
    // 获取DOM容器（用于Mermaid渲染）
    const containerRef = useRef<HTMLDivElement>(null);

    // 初始化+渲染：依赖code变化触发
    useEffect(() => {
      if (!containerRef.current || !code) return;

      // 配置Mermaid（主题、禁用自动加载）
      mermaid.initialize({
        theme: 'default',
        startOnLoad: false,
      });

      // 清空容器，避免重复渲染
      containerRef.current.innerHTML = '';

      // 渲染Mermaid代码为SVG
      mermaid.render('mermaid-chart', code, (svgCode) => {
        containerRef.current!.innerHTML = svgCode;
      });
    }, [code]); // 仅当code变化时重新渲染

    return <div ref={containerRef} className="mermaid-container"></div>;
  }
  ```
- **关键知识点**：
  ✅ `useRef`：获取 DOM 元素，用于第三方库（Mermaid）的渲染容器；
  ✅ `useEffect` 依赖：仅在 `code` 变化时重新渲染，避免无效执行；
  ✅ 第三方库配置：手动初始化 Mermaid，避免自动加载导致的渲染异常；
- **调用场景**：`Markdown.tsx` 中识别 `language-mermaid` 代码块时调用。

#### （3）`Ask.tsx`（Wiki 问答弹窗）
- **核心作用**：用户针对 Wiki 内容提问，返回上下文相关的回答；
- **核心代码（简化版）**：
  ```tsx
  'use client';
  import { useState } from 'react';
  import Button from '../ui/Button';
  import Modal from '../ui/Modal';
  import Input from '../ui/Input';

  interface AskProps {
    open: boolean;         // 弹窗显隐
    onClose: () => void;   // 关闭回调
    wikiContent: string;   // Wiki内容（提问上下文）
  }

  export default function Ask({ open, onClose, wikiContent }: AskProps) {
    // 内部状态：问题、加载态、回答
    const [question, setQuestion] = useState('');
    const [loading, setLoading] = useState(false);
    const [answer, setAnswer] = useState('');

    // 提交提问（异步逻辑）
    const handleSubmit = async () => {
      if (!question.trim()) return; // 空值校验
      setLoading(true);
      try {
        // 调用前端API，传入问题+Wiki上下文
        const res = await fetch('/api/ask', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ question, context: wikiContent }),
        });
        const data = await res.json();
        setAnswer(data.answer); // 存储回答
      } catch (err) {
        setAnswer('提问失败，请重试'); // 错误兜底
      } finally {
        setLoading(false); // 结束加载
      }
    };

    return (
      <Modal open={open} onClose={onClose}>
        <div className="ask-modal">
          <h3>针对Wiki提问</h3>
          {/* 受控输入框：value+onChange绑定 */}
          <Input
            placeholder="请输入你的问题..."
            value={question}
            onChange={(e) => setQuestion(e.target.value)}
            disabled={loading}
          />
          {/* 提交按钮：加载态禁用 */}
          <Button onClick={handleSubmit} disabled={loading}>
            {loading ? '提问中...' : '提交'}
          </Button>
          {/* 回答展示 */}
          {answer && <div className="answer">{answer}</div>}
        </div>
      </Modal>
    );
  }
  ```
- **关键知识点**：
  ✅ 受控表单：`Input` 的 `value` 绑定 `question` state，`onChange` 更新状态，是 React 表单标准写法；
  ✅ 异步处理：`async/await` 调用 API，`loading` 状态避免重复提交；
  ✅ 上下文传递：父组件（核心页）传入 `wikiContent` 作为提问上下文，实现「基于Wiki内容问答」；
- **调用场景**：核心页点击「提问」按钮时打开，依赖 Wiki 内容完成上下文问答。

### 3. 全局业务组件（`common/` 目录）
#### `ModelSelectionModal.tsx`（模型选择弹窗）
- **核心作用**：让用户选择生成 Wiki 的 AI 模型（GPT-3.5/GPT-4 等）；
- **核心逻辑亮点**：
  ✅ 子组件向父组件传值：通过 `onSelect` 回调将选中的模型传递给核心页；
  ✅ 内部状态管理：`selectedModel` 管理弹窗内的选中状态，默认值来自父组件 `defaultModel`；
  ✅ 选项遍历：通过数组 `MODEL_LIST` 遍历生成选项，避免重复代码；
- **调用场景**：核心页点击「选择模型」按钮时打开，选中后更新核心页的 `model` 状态。


**跟踪「调用链路」：结合 `app/` 目录**
比如在核心页（`app/[owner]/[repo]/page.tsx`）中找到 `<Markdown content={wikiContent.content} />`，再点进 `Markdown.tsx` 看：
- `content` props 是怎么被使用的；
- `Markdown` 内部又调用了 `<Mermaid />`，再跳转到 `Mermaid.tsx` 分析。

---

## 三、`types/`目录：明确数据结构
TypeScript 项目中，`types/` 定义了所有数据的格式，理解这些类型能帮你看懂其他文件中的变量和函数。  
- 例如 `types/wiki/wikistructure.tsx` 定义了 `WikiStructure` 接口，描述了 Wiki 的整体结构（包含哪些页面、每个页面的标题和内容等）。  
- 阅读时关注：接口中的字段（如 `id`、`title`、`pages`）分别代表什么，它们在 `app/` 或 `components/` 中是如何被使用的。  

### 深度拆解 `types/` 目录（TypeScript 类型定义核心）
`types/` 是 DeepWiki-Open 前端的「数据契约库」，所有前端数据（API 交互、组件 Props、业务逻辑中的变量）的结构都在这里定义。通过 TypeScript 的**接口（interface）、类型别名（type）** 规范数据格式，实现「类型安全」—— 提前拦截类型错误（如传数字给需要字符串的字段），避免运行时 Bug，同时让数据结构可视化，降低协作和维护成本。

```
types/
├── common/                # 通用类型（跨业务复用，如枚举、工具类型）
│   ├── enums.ts           # 枚举类型（模型、语言、请求状态）
│   └── utils.ts           # 工具类型（泛型、非空处理、基础组件属性）
├── wiki/                  # Wiki 核心业务类型（整体/单页面结构）
│   ├── wikistructure.ts   # Wiki 整体结构（核心接口）
│   └── page.ts            # Wiki 单页面结构
├── api/                   # API 交互类型（请求参数/响应数据）
│   ├── generate.ts        # 生成 Wiki 的 API 类型
│   └── ask.ts             # Wiki 问答的 API 类型
└── components/            # 组件 Props 类型（集中管理输入约束）
    ├── modal.ts           # Modal 组件 Props
    └── markdown.ts        # Markdown 组件 Props
```

### 1. 通用类型（`common/` 目录）
通用类型是「无业务耦合的基础类型」，跨 Wiki/API/组件复用，是 TypeScript 基础语法的核心体现。

#### （1）`enums.ts`（枚举类型：固定值集合）
枚举用于封装「有限、固定的可选值」，替代魔法字符串/数字（如直接写 `'gpt-3.5'`），提升可读性和可维护性。
```ts
// 1. AI 模型类型枚举（生成 Wiki/问答的可选模型）
export enum ModelType {
  GPT3_5 = 'gpt-3.5-turbo', // 语义化名称 = 实际传参值
  GPT4 = 'gpt-4',
  CLAUDE = 'claude-3-sonnet',
}

// 2. 语言类型枚举（多语言切换）
export enum LanguageType {
  ZH = 'zh-CN',
  EN = 'en-US',
}

// 3. 请求状态枚举（通用加载/成功/失败状态）
export enum RequestStatus {
  Idle = 'idle',       // 初始态
  Loading = 'loading', // 加载中
  Success = 'success', // 成功
  Error = 'error',     // 失败
}
```
- **核心知识点**：
  ✅ 枚举价值：修改值时只需改枚举定义（如 `GPT3_5` 改为 `gpt-3.5`），无需改所有使用处；
  ✅ 使用场景：`ModelSelectionModal` 遍历枚举生成选项、API 请求指定模型类型、核心页标记请求状态；
  ✅ 类型安全：`const model: ModelType = 'gpt-3'` 会直接报错，只能选枚举内的值。

#### （2）`utils.ts`（工具类型：通用类型处理）
工具类型是「类型层面的函数」，用于复用类型逻辑（如处理空值、适配不同 API 响应）。
```ts
// 1. 非空类型：排除 null/undefined（避免「读取 null 属性」错误）
export type NonNullable<T> = T extends null | undefined ? never : T;

// 2. API 响应通用类型：所有 API 响应都遵循此结构
export type ApiResponse<T> = {
  code: number;          // 状态码（200=成功，4xx=客户端错误）
  message: string;       // 提示信息（如「生成成功」）
  data?: T;              // 泛型数据：不同 API 响应数据不同
};

// 3. 基础组件属性：所有组件通用的样式属性
export type BaseComponentProps = {
  className?: string;    // 自定义样式类名
  style?: React.CSSProperties; // 内联样式
};
```
- **核心知识点**：
  ✅ 泛型（`<T>`）：「类型变量」，适配不同数据结构。比如 `ApiResponse<WikiStructure>` 表示「返回 Wiki 结构的 API 响应」，`ApiResponse<string>` 表示「返回字符串的响应」；
  ✅ 非空类型：`const wiki: NonNullable<WikiStructure> = ...` 确保 `wiki` 不会是 null/undefined；
  ✅ 复用价值：所有 API 响应都基于 `ApiResponse`，无需重复定义 `code`/`message` 字段。

### 2. Wiki 核心业务类型（`wiki/` 目录）
这类类型是「前端与后端的核心数据契约」，所有 Wiki 相关逻辑（渲染、存储、API 交互）都基于这些类型。

#### （1）`page.ts`（Wiki 单页面类型）
定义「一个 Wiki 页面」的最小数据结构，是构成 Wiki 整体的基础单元。
```ts
// Wiki 单页面接口（interface 适合复杂对象，支持扩展）
export interface WikiPage {
  id: string;                // 页面唯一 ID（UUID）
  title: string;             // 页面标题（如「快速开始」）
  content: string;           // 页面内容（Markdown 格式）
  order: number;             // 排序序号（侧边栏排序）
  parentId?: string;         // 父页面 ID（可选，用于嵌套目录）
  createdAt?: string;        // 创建时间（可选，ISO 格式）
}

// 扩展：编辑中的 Wiki 页面（继承 + 新增字段）
export interface EditableWikiPage extends WikiPage {
  isEditing: boolean;        // 是否处于编辑状态
}
```
- **核心知识点**：
  ✅ `interface` vs `type`：`interface` 支持 `extends` 扩展，适合定义业务对象；`type` 支持复杂类型运算（如联合、交叉），适合工具类型；
  ✅ 可选字段（`?`）：`parentId`/`createdAt` 非必传，避免「后端返回缺少该字段导致类型错误」；
  ✅ 接口扩展：`EditableWikiPage` 继承 `WikiPage` 所有字段，无需重复定义。

#### （2）`wikistructure.ts`（Wiki 整体结构类型）
定义「整个 Wiki 仓库」的数据结构，是核心业务接口，被 API 响应、核心页状态、Markdown 组件广泛使用。
```ts
import { WikiPage } from './page';
import { LanguageType } from '../common/enums';

// Wiki 整体结构接口
export interface WikiStructure {
  id: string;                // Wiki 唯一标识（如「owner-repo」）
  owner: string;             // 仓库所有者（如「deep-wiki」）
  repo: string;              // 仓库名称（如「wiki-demo」）
  title: string;             // Wiki 总标题（如「Wiki Demo 文档」）
  language: LanguageType;    // Wiki 语言（关联枚举，类型安全）
  pages: WikiPage[];         // Wiki 页面列表（数组，元素为 WikiPage）
  description?: string;      // Wiki 描述（可选）
  updatedAt?: string;        // 更新时间（可选）
}

// 简化版 Wiki 结构（列表展示用，提取核心字段）
export type SimplifiedWikiStructure = Pick<WikiStructure, 'id' | 'title' | 'owner' | 'repo'>;
// Pick：TypeScript 内置工具，从接口中提取指定字段
```
- **核心知识点**：
  ✅ 类型嵌套：`WikiStructure` 包含 `WikiPage[]` 数组，体现「整体-部分」的业务关系；
  ✅ 枚举关联：`language` 只能选 `LanguageType` 中的值（如 `zh-CN`/`en-US`），避免传 `'cn'` 这类不规范值；
  ✅ 内置工具类型（`Pick`）：快速生成简化类型，无需重复定义（如列表页只需展示 `id/title/owner/repo`）；
  ✅ 典型使用场景：
  ```ts
  // 核心页状态约束：wikiContent 只能是 WikiStructure 或 null
  import { WikiStructure } from '@/types/wiki/wikistructure';
  const [wikiContent, setWikiContent] = useState<WikiStructure | null>(null);
  ```

### 3. API 交互类型（`api/` 目录）
定义「前端与后端交互的数据格式」，分为「请求参数（Request）」和「响应数据（Response）」，是前后端协作的「契约」。

#### （1）`generate.ts`（生成 Wiki 的 API 类型）
```ts
import { ModelType } from '../common/enums';
import { ApiResponse } from '../common/utils';
import { WikiStructure } from '../wiki/wikistructure';

// 生成 Wiki 的 API 请求参数
export interface GenerateWikiRequest {
  owner: string;             // 仓库所有者（必传）
  repo: string;              // 仓库名称（必传）
  model: ModelType;          // 模型类型（关联枚举，必传）
  language?: LanguageType;   // 生成语言（可选，默认 zh-CN）
}

// 生成 Wiki 的 API 响应（复用通用 ApiResponse + Wiki 结构）
export type GenerateWikiResponse = ApiResponse<WikiStructure>;
```
- **核心知识点**：
  ✅ 请求参数约束：`owner`/`repo`/`model` 必传，前端调用 API 时缺少会直接报错；
  ✅ 响应复用：基于 `ApiResponse` 泛型，快速定义响应类型，无需重复写 `code`/`message`；
  ✅ 典型使用场景：
  ```ts
  // API 调用函数的参数/返回值约束
  const generateWiki = async (params: GenerateWikiRequest): Promise<WikiStructure | undefined> => {
    const res = await fetch('/api/generate', {
      method: 'POST',
      body: JSON.stringify(params), // params 必须符合 GenerateWikiRequest
    });
    const data: GenerateWikiResponse = await res.json();
    return data.data;
  };
  ```

#### （2）`ask.ts`（Wiki 问答的 API 类型）
```ts
import { ModelType } from '../common/enums';
import { ApiResponse } from '../common/utils';

// 问答 API 请求参数
export interface AskWikiRequest {
  question: string;          // 用户问题（必传）
  context: string;           // Wiki 上下文（必传）
  model: ModelType;          // 模型类型（必传）
}

// 问答 API 响应数据（业务数据）
export interface AskWikiData {
  answer: string;            // 回答内容（Markdown 格式）
  thinking?: string;         // 思考过程（可选，调试用）
}

// 问答 API 响应类型（通用响应 + 业务数据）
export type AskWikiResponse = ApiResponse<AskWikiData>;
```
- **核心亮点**：将「通用响应结构」和「业务数据」分离，既复用通用逻辑，又明确业务字段，符合「单一职责」。

### 4. 组件 Props 类型（`components/` 目录）
集中管理组件的 Props 类型，避免「组件内部定义 Props 导致分散」，修改时只需改一处。

#### （1）`modal.ts`（Modal 组件 Props 类型）
```ts
import { BaseComponentProps } from '../common/utils';

// Modal Props（继承基础样式属性 + 自有属性）
export interface ModalProps extends BaseComponentProps {
  open: boolean;             // 控制显隐（必传）
  onClose: () => void;       // 关闭回调（必传）
  title?: string;            // 弹窗标题（可选）
  size?: 'small' | 'medium' | 'large'; // 弹窗尺寸（联合类型）
}
```
- **核心知识点**：
  ✅ 继承复用：`ModalProps` 继承 `BaseComponentProps` 的 `className`/`style`，无需重复定义；
  ✅ 联合类型：`size` 只能选 `small/medium/large`，比枚举更轻量（适合少量固定值）；
  ✅ 典型使用场景：
  ```ts
  // Modal 组件的 Props 约束
  import { ModalProps } from '@/types/components/modal';
  export default function Modal({ open, onClose, size = 'medium' }: ModalProps) {
    // 编辑器自动提示 Props 字段，传错值直接报错
  }
  ```

#### （2）`markdown.ts`（Markdown 组件 Props 类型）
```ts
import { BaseComponentProps } from '../common/utils';

export interface MarkdownProps extends BaseComponentProps {
  content: string;           // Markdown 内容（必传）
  enableMermaid?: boolean;   // 是否启用 Mermaid 渲染（可选，默认 true）
  enableHighlight?: boolean; // 是否启用代码高亮（可选，默认 true）
}
```
- **核心价值**：所有使用 `Markdown` 组件的地方都复用该类型，修改 `enableMermaid` 时只需改这里，无需改所有调用处。

### 1. 「场景→类型」反向推导
不要孤立看 `types/` 目录，结合 `app/`/`components/` 找使用场景：
- 比如在核心页看到 `const [wikiContent, setWikiContent] = useState<WikiStructure | null>(null)`，再跳转到 `types/wiki/wikistructure.ts` 看字段含义；
- 比如在 `Ask.tsx` 看到 `fetch('/api/ask', { body: JSON.stringify(params) })`，再看 `types/api/ask.ts` 约束 `params` 的结构。

### 2. 跟踪「类型引用链路」
比如：
1. `GenerateWikiResponse` → 引用 `ApiResponse` 和 `WikiStructure`；
2. `WikiStructure` → 引用 `WikiPage` 和 `LanguageType`；
3. `LanguageType` → 来自 `common/enums.ts`；
通过链路理清类型依赖，理解整个数据体系。

---

## 四、`hooks/` 目录深度拆解

React 内置 Hooks（`useState`/`useEffect`/`useRef`）解决了组件内状态和副作用管理，但业务逻辑（如「生成 Wiki 的 API 请求+加载态+错误处理」）会在多个组件中重复，`hooks/` 就是将这些逻辑封装为**自定义 Hook**，实现「一次封装、多处调用」。

```
hooks/
├── common/                # 通用 Hook（跨业务复用，如请求、防抖）
│   ├── useRequest.ts      # 通用 API 请求 Hook（加载态+错误+重试）
│   └── useDebounce.ts     # 防抖 Hook（输入框去重）
└── wiki/                  # Wiki 业务专属 Hook（绑定核心逻辑）
    ├── useProcessedProjects.ts  # 处理 Wiki 项目数据（过滤/排序）
    ├── useWikiGenerate.ts       # 封装 Wiki 生成的请求逻辑
    └── useWikiAsk.ts            # 封装 Wiki 问答的请求逻辑
```

### 3. 关键 Hook 逐类拆解（附代码+核心知识点）
#### （1）通用 Hook：`common/useRequest.ts`（核心复用 Hook）
封装所有 API 请求的通用逻辑（加载态、错误处理、重试），避免每个请求都写重复的 `useState`/`async/await`。
```ts
'use client'; // Hook 依赖客户端状态，必须声明
import { useState, useCallback } from 'react';

// 泛型：适配任意请求参数和响应数据类型
interface UseRequestOptions<T = any, P = any> {
  // 请求函数（入参 P，返回 Promise<T>）
  requestFn: (params: P) => Promise<T>;
  // 是否初始化自动请求（默认 false）
  immediate?: boolean;
  // 重试次数（默认 0）
  retryCount?: number;
}

// Hook 返回值类型
interface UseRequestResult<T = any, P = any> {
  data: T | null;         // 请求结果
  loading: boolean;       // 加载态
  error: string | null;   // 错误信息
  // 手动触发请求（参数透传给 requestFn）
  run: (params: P) => Promise<void>;
  // 重置状态
  reset: () => void;
}

// 自定义 Hook 实现
export function useRequest<T = any, P = any>({
  requestFn,
  immediate = false,
  retryCount = 0,
}: UseRequestOptions<T, P>): UseRequestResult<T, P> {
  // 1. 状态管理：加载态、数据、错误
  const [loading, setLoading] = useState(false);
  const [data, setData] = useState<T | null>(null);
  const [error, setError] = useState<string | null>(null);

  // 2. 重置状态函数（复用）
  const reset = useCallback(() => {
    setLoading(false);
    setData(null);
    setError(null);
  }, []);

  // 3. 核心请求逻辑（封装重试）
  const run = useCallback(
    async (params: P) => {
      reset(); // 每次请求前重置状态
      setLoading(true);
      let retry = retryCount;

      // 重试逻辑
      while (retry >= 0) {
        try {
          const res = await requestFn(params); // 执行传入的请求函数
          setData(res);
          setError(null);
          break; // 成功则退出重试
        } catch (err) {
          retry--;
          if (retry < 0) {
            // 重试耗尽，记录错误
            setError(err instanceof Error ? err.message : '请求失败');
          }
        } finally {
          setLoading(false);
        }
      }
    },
    [requestFn, reset, retryCount] // 依赖项：避免重复创建函数
  );

  // 4. 初始化自动请求（immediate=true 时）
  useState(() => {
    if (immediate) {
      // 若需初始化请求，需确保 params 存在（此处简化，实际可传默认 params）
      // run(defaultParams);
    }
  }, [immediate, run]);

  // 返回状态和方法（供组件调用）
  return { data, loading, error, run, reset };
}
```
- **核心知识点**：
  ✅ 泛型（`<T, P>`）：适配任意请求参数和响应类型（如 Wiki 生成请求用 `T=WikiStructure`，问答请求用 `T=AskWikiData`）；
  ✅ `useCallback`：缓存函数，避免因函数重新创建导致组件重复渲染；
  ✅ 通用逻辑封装：加载态、错误处理、重试、重置，所有 API 请求都可复用，无需重复写；
  ✅ 典型使用场景：
  ```ts
  // 在 Wiki 生成 Hook 中复用 useRequest
  import { useRequest } from '@/hooks/common/useRequest';
  import { generateWiki } from '@/utils/api';
  import { GenerateWikiRequest, WikiStructure } from '@/types/api/generate';

  export function useWikiGenerate() {
    // 复用通用请求 Hook，指定参数/响应类型
    const { data, loading, error, run, reset } = useRequest<WikiStructure, GenerateWikiRequest>({
      requestFn: generateWiki, // 传入具体的请求函数
      retryCount: 1, // 重试 1 次
    });

    // 封装业务逻辑：生成 Wiki（透传参数）
    const generate = (params: GenerateWikiRequest) => run(params);

    return { wikiData: data, loading, error, generate, reset };
  }
  ```

#### （2）Wiki 业务 Hook：`wiki/useWikiGenerate.ts`（业务逻辑封装）
基于通用 `useRequest` 封装「生成 Wiki」的专属逻辑，聚焦业务，屏蔽通用请求细节。
```ts
'use client';
import { useRequest } from '../common/useRequest';
import { generateWiki as fetchGenerateWiki } from '@/utils/api';
import type { GenerateWikiRequest, WikiStructure } from '@/types/api/generate';

// 业务 Hook：仅暴露 Wiki 生成相关的状态和方法
export function useWikiGenerate() {
  // 复用通用请求 Hook，绑定 Wiki 生成的请求函数
  const {
    data: wikiData,
    loading,
    error,
    run: doGenerate,
    reset,
  } = useRequest<WikiStructure, GenerateWikiRequest>({
    requestFn: fetchGenerateWiki,
    retryCount: 1, // 业务定制：重试 1 次
  });

  // 业务封装：生成 Wiki（参数校验+调用请求）
  const generateWiki = async (params: GenerateWikiRequest) => {
    // 业务校验：必填参数检查
    if (!params.owner || !params.repo) {
      throw new Error('仓库所有者/名称不能为空');
    }
    await doGenerate(params); // 调用通用请求的 run 方法
  };

  // 返回简化的业务接口（屏蔽通用 Hook 的细节）
  return {
    wikiData,    // 生成的 Wiki 数据
    isGenerating: loading, // 语义化命名：更贴合业务
    generateError: error,  // 语义化命名
    generateWiki,          // 生成方法
    resetGenerate: reset,  // 重置方法
  };
}
```
- **核心知识点**：
  ✅ 业务封装：在通用 Hook 基础上增加「参数校验」「语义化命名」，更贴合业务场景；
  ✅ 屏蔽细节：组件调用时只需关注 `generateWiki`/`isGenerating`，无需关心请求重试、状态管理细节；
  ✅ 典型使用场景（核心页）：
  ```tsx
  'use client';
  import { useWikiGenerate } from '@/hooks/wiki/useWikiGenerate';
  import { useParams } from 'next/navigation';

  export default function WikiPage() {
    const params = useParams();
    const { wikiData, isGenerating, generateError, generateWiki } = useWikiGenerate();

    // 点击生成按钮触发
    const handleGenerate = () => {
      generateWiki({
        owner: params.owner as string,
        repo: params.repo as string,
        model: 'gpt-3.5-turbo',
      });
    };

    return (
      <div>
        <button onClick={handleGenerate} disabled={isGenerating}>
          {isGenerating ? '生成中...' : '生成 Wiki'}
        </button>
        {generateError && <div className="error">{generateError}</div>}
        {wikiData && <Markdown content={wikiData.content} />}
      </div>
    );
  }
  ```

#### （3）Wiki 业务 Hook：`wiki/useProcessedProjects.ts`（数据处理）
封装「Wiki 项目列表过滤、排序、格式化」的逻辑，避免在多个组件中重复处理数据。
```ts
'use client';
import { useState, useMemo } from 'react';
import type { SimplifiedWikiStructure } from '@/types/wiki/wikistructure';

// Hook 参数：原始项目列表 + 过滤关键词
interface UseProcessedProjectsParams {
  rawProjects: SimplifiedWikiStructure[];
  filterKeyword?: string;
}

export function useProcessedProjects({ rawProjects, filterKeyword = '' }: UseProcessedProjectsParams) {
  // 排序方式：状态管理（组件内可切换）
  const [sortType, setSortType] = useState<'title' | 'owner'>('title');

  // 处理后的数据：用 useMemo 缓存，仅当依赖变化时重新计算
  const processedProjects = useMemo(() => {
    // 1. 过滤：根据关键词匹配 title/owner/repo
    const filtered = rawProjects.filter((project) => {
      const keyword = filterKeyword.toLowerCase();
      return (
        project.title.toLowerCase().includes(keyword) ||
        project.owner.toLowerCase().includes(keyword) ||
        project.repo.toLowerCase().includes(keyword)
      );
    });

    // 2. 排序：按 sortType 排序
    const sorted = filtered.sort((a, b) => {
      if (sortType === 'title') {
        return a.title.localeCompare(b.title);
      } else {
        return a.owner.localeCompare(b.owner);
      }
    });

    return sorted;
  }, [rawProjects, filterKeyword, sortType]); // 依赖项：仅这些变化时重新处理

  // 返回处理后的数据 + 排序控制方法
  return {
    processedProjects,
    sortType,
    setSortType, // 供组件切换排序方式
  };
}
```
- **核心知识点**：
  ✅ `useMemo`：缓存计算结果，避免每次组件渲染都重新过滤/排序（性能优化）；
  ✅ 单一职责：仅处理项目数据的过滤和排序，不涉及 UI 渲染；
  ✅ 状态内聚：排序方式（`sortType`）作为 Hook 内部状态，组件只需调用 `setSortType` 即可切换。

## 五、`contexts/` 目录深度拆解
### 1. `contexts/` 核心定位
React 组件间传递数据默认靠 `Props`，但跨多层组件（如「根布局→核心页→Markdown 组件→Mermaid 组件」）传递「当前语言」时，Props 层层传递会非常繁琐（Prop Drilling）。`contexts/` 就是通过 **React Context** 将状态「提升到全局」，让任意组件都能直接访问，无需手动传递 Props。

### 2. `contexts/` 目录完整结构
按「状态类型」划分，一个 Context 管理一类状态（最小粒度原则）：
```
contexts/
├── LanguageContext.tsx   # 全局语言状态（多语言切换）
├── ModelContext.tsx      # 全局模型状态（AI 模型选择）
└── index.ts              # 统一导出所有 Context（简化导入）
```

### 3. 关键 Context 逐类拆解（附代码+核心知识点）
#### （1）核心 Context：`LanguageContext.tsx`（多语言管理）
管理全局语言状态（如 `zh-CN`/`en-US`），支持任意组件读取/切换语言。
```tsx
'use client';
import { createContext, useContext, useState, ReactNode } from 'react';
import { LanguageType } from '@/types/common/enums';

// 1. 定义 Context 的值类型（状态+方法）
interface LanguageContextValue {
  currentLang: LanguageType; // 当前语言（关联枚举）
  setCurrentLang: (lang: LanguageType) => void; // 切换语言的方法
}

// 2. 创建 Context（默认值为 undefined，需用 Provider 包裹才能使用）
const LanguageContext = createContext<LanguageContextValue | undefined>(undefined);

// 3. 定义 Context Provider（包裹需要共享状态的组件树）
interface LanguageProviderProps {
  children: ReactNode; // 子组件（被 Provider 包裹的内容）
  defaultLang?: LanguageType; // 默认语言（可选，默认 zh-CN）
}

export function LanguageProvider({ children, defaultLang = LanguageType.ZH }: LanguageProviderProps) {
  // 状态管理：当前语言
  const [currentLang, setCurrentLang] = useState<LanguageType>(defaultLang);

  // 封装切换方法（可选：可增加业务逻辑，如持久化到 localStorage）
  const changeLang = (lang: LanguageType) => {
    setCurrentLang(lang);
    // 可选：持久化到本地存储，刷新后保留
    localStorage.setItem('deepwiki-lang', lang);
  };

  // Context 的值：状态 + 方法
  const contextValue: LanguageContextValue = {
    currentLang,
    setCurrentLang: changeLang,
  };

  // 4. 提供 Context：用 Provider 包裹子组件，传递状态
  return (
    <LanguageContext.Provider value={contextValue}>
      {children}
    </LanguageContext.Provider>
  );
}

// 5. 封装自定义 Hook：简化组件调用（避免重复写 useContext + 校验）
export function useLanguage() {
  const context = useContext(LanguageContext);
  // 若组件未在 Provider 包裹内使用，抛出错误（提示用户）
  if (!context) {
    throw new Error('useLanguage must be used within a LanguageProvider');
  }
  return context;
}
```
- **核心知识点**：
  ✅ `createContext`：创建 Context 容器，定义共享状态的类型；
  ✅ `Provider`：包裹组件树，将状态注入所有子组件（通常在根布局 `app/layout.tsx` 中使用）；
  ✅ `useContext`：组件中读取 Context 状态，封装为 `useLanguage` 简化调用+错误校验；
  ✅ 状态持久化：切换语言时存入 `localStorage`，刷新页面后恢复；
  ✅ 典型使用场景（根布局注入）：
  ```tsx
  // app/layout.tsx
  import { LanguageProvider } from '@/contexts/LanguageContext';

  export default function RootLayout({ children }) {
    return (
      <html>
        <body>
          {/* 全局注入语言 Context，所有子组件都能访问 */}
          <LanguageProvider>
            {children}
          </LanguageProvider>
        </body>
      </html>
    );
  }
  ```
  ✅ 典型使用场景（组件中调用）：
  ```tsx
  // 任意组件（如 Header 语言切换按钮）
  import { useLanguage } from '@/contexts/LanguageContext';
  import { LanguageType } from '@/types/common/enums';

  export default function LanguageSwitch() {
    const { currentLang, setCurrentLang } = useLanguage();

    return (
      <div>
        <button onClick={() => setCurrentLang(LanguageType.ZH)} disabled={currentLang === LanguageType.ZH}>
          中文
        </button>
        <button onClick={() => setCurrentLang(LanguageType.EN)} disabled={currentLang === LanguageType.EN}>
          English
        </button>
      </div>
    );
  }
  ```

#### （2）业务 Context：`ModelContext.tsx`（全局模型管理）
管理全局选中的 AI 模型（如 `gpt-3.5-turbo`/`gpt-4`），核心页、模型选择弹窗、问答组件都能访问。
```tsx
'use client';
import { createContext, useContext, useState, ReactNode } from 'react';
import { ModelType } from '@/types/common/enums';

// 1. 定义 Context 值类型
interface ModelContextValue {
  currentModel: ModelType;
  setCurrentModel: (model: ModelType) => void;
}

// 2. 创建 Context
const ModelContext = createContext<ModelContextValue | undefined>(undefined);

// 3. 定义 Provider
interface ModelProviderProps {
  children: ReactNode;
  defaultModel?: ModelType; // 默认模型：gpt-3.5-turbo
}

export function ModelProvider({ children, defaultModel = ModelType.GPT3_5 }: ModelProviderProps) {
  // 状态：从本地存储读取（优先），否则用默认值
  const [currentModel, setCurrentModel] = useState<ModelType>(
    (localStorage.getItem('deepwiki-model') as ModelType) || defaultModel
  );

  // 封装切换方法：更新状态 + 持久化
  const changeModel = (model: ModelType) => {
    setCurrentModel(model);
    localStorage.setItem('deepwiki-model', model);
  };

  const contextValue: ModelContextValue = {
    currentModel,
    setCurrentModel: changeModel,
  };

  return (
    <ModelContext.Provider value={contextValue}>
      {children}
    </ModelContext.Provider>
  );
}

// 4. 封装自定义 Hook
export function useModel() {
  const context = useContext(ModelContext);
  if (!context) {
    throw new Error('useModel must be used within a ModelProvider');
  }
  return context;
}
```
- **核心亮点**：
  ✅ 持久化优先：初始化时从 `localStorage` 读取上次选中的模型，提升用户体验；
  ✅ 业务联动：核心页调用 `useModel` 获取当前模型，传递给 `useWikiGenerate` 作为请求参数；
  ✅ 典型使用场景（核心页）：
  ```tsx
  import { useModel } from '@/contexts/ModelContext';
  import { useWikiGenerate } from '@/hooks/wiki/useWikiGenerate';

  export default function WikiPage() {
    const { currentModel } = useModel(); // 获取全局模型
    const { generateWiki, isGenerating } = useWikiGenerate();

    const handleGenerate = () => {
      generateWiki({
        owner: 'deep-wiki',
        repo: 'demo',
        model: currentModel, // 使用全局模型
      });
    };

    return <button onClick={handleGenerate}>{isGenerating ? '生成中' : '生成 Wiki'}</button>;
  }
  ```


## `hooks/` 和 `contexts/` 的关联与协同
两者并非孤立，而是互补协同：
1. **Context 提供全局状态，Hook 封装使用状态的逻辑**：
   比如 `useLanguage` Hook 内部调用 `useContext(LanguageContext)`，组件只需调用 `useLanguage` 即可获取/切换语言，无需直接操作 Context；
2. **Hook 可依赖 Context 状态**：
   比如 `useWikiGenerate` Hook 可调用 `useModel()` 获取全局模型，作为请求参数，无需组件手动传递；
3. **Context 状态变化触发 Hook 重新执行**：
   比如切换模型后，`useModel()` 返回的 `currentModel` 变化，依赖该值的 `useWikiGenerate` 会重新计算，保证数据最新。

